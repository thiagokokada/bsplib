.TH "bsp_get" 3 "1.4 25/9/98" "Oxford BSP Toolset" "BSPlib FUNCTIONS"
.SH NAME
bsp_get, bsp_hpget \- copy data from a remote processes memory

.SH C SYNOPSIS
.nf
.B #include \&"bsp.h\&"
.PP
.BI "void bsp_get(int " pid ",const void *" src\c
.BI ", int " offset ",void *" dst "\c
.BI ",int " nbytes ");"
.PP
.BI "void bsp_hpget(int " pid ",const void *" src\c
.BI ", int " offset ",void *" dst "\c
.BI ",int " nbytes ");"
.PP
.fi
.SH FORTRAN SYNOPSIS 
.nf
.BI "SUBROUTINE  bspget(" pid,src,offset,dst,nbytes)
.BI "  INTEGER, intent(IN)  :: " pid , offset , nbytes
.BI "  <TYPE>,  intent(IN)  :: " src 
.BI "  <TYPE>,  intent(OUT) :: " dst
.PP
.BI "SUBROUTINE  bsphpget(" pid,src,offset,dst,nbytes)
.BI "  INTEGER, intent(IN)  :: " pid , offset , nbytes
.BI "  <TYPE>,  intent(IN)  :: " src 
.BI "  <TYPE>,  intent(OUT) :: " dst
.PP
.fi

.SH DESCRIPTION

The 
.B bsp_get(3)
and
.B bsp_hpget(3)
operations reach into the local memory of another process and copy
previously registered remote data held there into a data structure in
the local memory of the process that initiated them.
     
The semantics 
.I "buffered on source, buffered on destination"
is used for 
.B bsp_get(3)
communications.  This
semantics means that the value taken from the source on the
remote process by the get, is the value available once the
remote process finishes executing all its superstep
computations.  Furthermore, writing the value from the remote
process into the destination memory area on the initiating
process only takes effect at the end of the superstep after all
remote reads from any other 
.B bsp_get(3)
operations are performed, 
.I but before
any data is written by any 
.B bsp_put(3)\c
\&. Therefore, computation and buffered communication operations
within a superstep can be 
.I thought
to occur in the following order:

.IP 1
local computation is performed; also, when a
.B bsp_put(3)
is excecuted, the associated source data is read;
     
.IP 2
the source data associated with all
.B bsp_get(3)
operations are read;

.IP 3
data associated with any 
.B bsp_put(3)
or
.B bsp_get(3)
are written into the destination data
structures.

A high-performance version of get,
.B bsp_hpget(3)\c
\&, provides the 
.I "unbuffered on source, unbuffered on destination"
semantics in which the two-way communication can take effect at any
time during the superstep. 

.SH EXAMPLES

.IP 1)
The procedure 
.I get_array
is the dual of 
.I put_array
defined in the manual page for
.B bsp_put(3)\c
\&. The procedure is semantically equivalent to the concurrent
assignment:

forall i in {0,..,n-1} xs[i] := xs[xs[i]]

.nf
void get_array(int *xs, int n) {
  int i,pid,local_idx,n_over_p=n/bsp_nprocs();
  if (n % bsp_nprocs()) 
    bsp_abort("{get_array} %d not divisible by %d",
              n,bsp_nprocs());
  bsp_push_reg(xs,n_over_p*sizeof(int));
  bsp_sync();

  for(i=0;i<n_over_p;i++) {
    pid       = xs[i]/n_over_p;
    local_idx = xs[i]%n_over_p;
    bsp_get(pid,xs,local_idx*sizeof(int),&xs[i],sizeof(int));
  }
  bsp_sync();
  bsp_pop_reg(xs);
}
.fi

Similarly, the function can be defined in Fortran as:

.nf
        SUBROUTINE getarray(xs,n)
          INCLUDE 'fbsp.h'
          INTEGER xs(*),n
          INTEGER i,pid,localidx,noverp

          noverp=n/bspnprocs()
          IF (MOD(n,bspnprocs()) .NE. 0) THEN
            CALL bspabort('N not divisible by p')
          END IF
          CALL bsppushreg(xs,noverp*BSPINT)
          CALL bspsync()
          DO i=1,noverp
            pid      = xs(i)/noverp
            localidx = MOD(xs(i),noverp)
            CALL bspget(pid,xs,localidx*BSPINT,xs(i),BSPINT)
          END DO
          CALL bspsync()
          CALL bsppopreg(xs)
        END
.fi

In this example buffering is necessary as processes need to read data
before it is overwritten. Thus, for a given array element
.I xs[i]\c
\&, all reads generated by
.B bsp_get(3)
are performed ahead of the writes generated by any buffered operation,
including those due to the
.B bsp_get(3)
of the process on which
.I xs[i]
resides.

.IP 2)
The function 
.I bsp_sum
defined below is a collective communication (i.e., all processes have
to call the function), such that when process 
.I i
calls the function with an array
.I xs
containing 
.I nelem_i\c
\&, then the result on 
.I all
the processes will be the sum of all the arrays from all the
processes.

.nf
int bsp_sum(int *xs, int nelem) {
  int *local_sums,i,j,result=0;
  for(j=0;j<nelem;j++) result += xs[j];
  bsp_push_reg(&result,sizeof(int));
  bsp_sync();

  local_sums = calloc(bsp_nprocs(),sizeof(int));
  if (local_sums==NULL)
    bsp_abort("{bsp_sum} no memory for %d int",bsp_nprocs());
  for(i=0;i<bsp_nprocs();i++)
    bsp_hpget(i,&result,0,&local_sums[i],sizeof(int));
  bsp_sync();

  result=0;
  for(i=0;i<bsp_nprocs();i++) result += local_sums[i];
  bsp_pop_reg(&result); 
  free(local_sums);
  return result;
}
.fi

Similarly, the function can be defined in Fortran as:

.nf
        INTEGER FUNCTION bspsum(xs,nelem)
          INCLUDE 'fbsp.h'
          INTEGER xs(*),nelem,MAXPROCS
          PARAMETER (MAXPROCS=40)
          INTEGER i,j,result,localsums(MAXPROCS)

          result=0
          DO j=1,nelem
            result = result + xs(j)
          END DO
          
          CALL bsppushreg(result,BSPINT)
          CALL bspsync()
          DO i=0,bspnprocs()-1
            CALL bsphpget(i,result,0,localsums(i+1),BSPINT)
          END DO
          CALL bspsync()

          result=0
          DO i=1,bspnprocs()
            result=result+localsums(i)
          END DO
          CALL bsppopreg(result)
          bspsum=result
        END
.fi

The function contains three supersteps. In the first, the local
array 
.I xs
of each process is summed and assigned to the
variable 
.I result\c
\&. This variable is then registered for
communication in the subsequent superstep. Next, each local
.I result
is broadcast into the 
.I bsp_pid()th
element of 
.I local_sums} 
on every process. Unlike the previous examples, an unbuffered
communication is used in preference to a buffered
.B bsp_get(3)
because the variable 
.I result
is not used in any local computation during the same superstep as the
communication.  In the final superstep of the algorithm, each process
returns the sum of the 
.I p
values obtained from each process.

.IP 3)
Consider a function 
.I cyclic_shift
executed on each process, that takes an integer
.I x
as its argument, and returns the value of 
.I x
on its left neighbouring process.

.nf
int cyclic_shift(int x) {
  bsp_push_reg(&x,sizeof(int));
  bsp_sync();
  bsp_get( (bsp_pid()==0)?(bsp_nprocs()-1):bsp_pid()-1,
           &x,0,
           &x,
           sizeof(int));
  bsp_sync();
  bsp_pop_reg(&x);
  return result;
}
.fi

.IP 4)
An alternative definition of
.I cyclic shift
that uses a high performance get.
.nf
int cyclic_shift(int x) {
  int result;
  bsp_push_reg(&x,sizeof(int));
  bsp_sync();
  bsp_hpget( (bsp_pid()==0)?(bsp_nprocs()-1):bsp_pid()-1,
             &x,0,
             &result,
             sizeof(int));
  bsp_sync();
  bsp_pop_reg(&result);
  return result;
}
.fi

.IP 5)
Consider an alternative definition of a function 
.I bsp_allsums
that calculates the running sums of 
.I p 
values stored on
.I p
processors using a logorithmic technique. i.e., if
.I x_i 
is stored on process 
.I i\c
\&, then the result on each processor is
.I x_0 + .. x_i\c
\&.

.nf
#include "bsp.h"
#include <stdio.h>

int bsp_allsums(int x) {
  int i, left, right;

  bsp_push_reg(&right,sizeof(int));
  bsp_sync();

  right=x;
  for(i=1;i<bsp_nprocs();i*=2) {
    if (bsp_pid() >= i)
      bsp_get(bsp_pid()-i,&right,0,&left,sizeof(int));
    bsp_sync();
    if (bsp_pid()>=i) right=left+right;
  }
  bsp_pop_reg(&right);
  return right;
}

void main() {
  int y;
  bsp_begin(bsp_nprocs());
  y = bsp_pid()+1;
  printf("y=%d sums=%d\\n",y,bsp_allsums(y));
  bsp_end();
}
.fi

A compilation, and an example run on four processors is shown below:

.nf
pippin> bspcc allsums.c
pippin> ./a.out
y=4 sums=10
y=2 sums=3
y=1 sums=1
y=3 sums=6
.fi


.SH "SEE ALSO"
drma(3), bsp_push_reg(3), bsp_pop_reg(3), bsp_put(3), bsp_hpput(3)

.I ``BSPlib: The BSP Programming Library''
Jonathan M. D. Hill, Bill McColl, Dan C. Stefanescu, Mark W. Goudreau,
Kevin Lang, Satish B. Rao, , Torsten Suel, Thanasis Tsantilas, and Rob
Bisseling. Parallel Computing, to appear 1998. See
.I http://www.bsp-worldwide.org
for more details.


.SH NOTES
.IP i
The source memory area used in a get has to be
registered. It is an error to fetch from a data structure that
has not been registered.

.IP ii
The destination of a get does 
.I "not have to be registered."

.IP iii
If the source memory area 
.I src
is registered with size 
.I x\c
\&, then it is a bounds error to perform the
communication 
.I "bsp_get(pid,src,o,dst,n)"
if
.I o+n>x\c
\&.

.IP iv
A communication of zero bytes does nothing.

.IP v
A process can read from its own memory if 
.I pid = bsp_pid()\c
\&. However, due to the 
.I "buffered at destination"
semantics of 
.B bsp_get(3)\c
\&, the memory copy only takes effect 
.I "at the end of the superstep"\c
\&; i.e, the source data is read and then written at the end of the
superstep.

.SH BUGS
Problems and bug reports should be mailed to 
.I bsplib-bugs@comlab.ox.ac.uk

.SH AUTHORS
The Oxford BSP Toolset implementation of BSPlib was written by
Jonathan.Hill@comlab.ox.ac.uk
.br
.B http://www.comlab.ox.ac.uk/oucl/people/jonathan.hill.html
